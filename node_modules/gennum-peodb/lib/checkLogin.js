//============================================================================//

var print = console.log;

var ldap = require('gennum-ldap');

var crypto = require('crypto');

var hashPrefix = 'PEODB-';

//============================================================================//

function genPassHash(password) {
  var hashData = hashPrefix + password;
  return crypto.createHash('sha256').update(hashData).digest('hex');
}

//============================================================================//

module.exports = function(PEODB) {

  PEODB.prototype.checkLogin = function(callsign, password, cb) {
    var peodb = this;
    peodb.dbSession(function(db, cb) {
      checkLogin(db, callsign, password, cb);
    }, cb);
  }
}

//============================================================================//

function checkLogin(db, callsign, password, cb) {

  checkPassHash(db, callsign, password, function(err, userData, success) {
    if (err) {
      return cb(err);
    }

    if (success) {
      return cb(null, userData); // the cached passhash matched
    }

    if (userData.user_id < 0) { // do not check LDAP for system-users
      return cb(Error('bad system-user password'));
    }

    ldap.checkLogin(callsign, password, [], function(err, ldapData) {
      if (err) {
        print('ldap.checkLogin error:', err);
        return cb(err);
      }

      savePassHash(db, userData.user_id, password, function(err) {
        if (err) {
          // ignore the error, the user did login successfully
          print('> savePassHash ERROR: ' + err.toString());
        }
        return cb(null, userData);
      });
    });
  });
}

//============================================================================//

function checkPassHash(db, callsign, password, cb) {
  var qStr =
    'SELECT'
  + '   u.user_id, u.ldap_id, u.name, u.phone, u.email, u.location'
  + ' , uh.passhash'
  + ' FROM users u'
  + ' LEFT JOIN user_hashes uh ON (uh.user_id = u.user_id)'
  + ' WHERE u.callsign = ' + db.escape(callsign)
  ;
  db.queryData(qStr, function(err, data) {
    if (err) {
      return cb(err);
    }
    if (data.rows.length !== 1) {
      return cb(Error('unknown user'));
    }
    var userData = data.rows[0].toMap();
    if (userData.passhash === null) {
      return cb(null, userData, false);
    }
    var success = (userData.passhash === genPassHash(password));
    delete userData.passhash;
    return cb(null, userData, success);
  });
}

//============================================================================//

function savePassHash(db, user_id, password, cb) {
  // FIXME - should we be storing new users as well as their hashes here?
  var passhash = db.escape(genPassHash(password));
  var qStr =
    'INSERT INTO user_hashes (user_id, passhash, passtime)'
  + ' VALUES '
  +   '(' + db.escape(user_id)
  +   ',' + passhash
  +   ',UNIX_TIMESTAMP()'
  +   ')'
  + ' ON DUPLICATE KEY UPDATE'
  + '  passhash = ' + passhash
  + ', passtime = UNIX_TIMESTAMP()'
  ;
  db.queryData(qStr, cb);
}

//============================================================================//
