//============================================================================//

var print = console.log;

var async = require('async');

//============================================================================//

module.exports = function(PEODB) {

  var requiredArgs = [
    'user_id',
    'tp_rev_id',
    'editData', // see the checkFields() function
  ];

  PEODB.prototype.editTPrev = function(args, cb) {
    var peodb = this;

    var missingArg = peodb.checkArgs(requiredArgs, args);
    if (missingArg) {
      return cb(Error('missing required argument: ' + missingArg));
    }

    checkFields(peodb, args, function(err, draftOnly) {
      if (err) {
        return cb(err);
      }
      // FIXME - use the draftOnly value
      var db = peodb.sharedDB;
      var qStr = 'UPDATE tp_revs';
      var editData = args.editData;
      var fieldArray = [];
      for (var field in editData) {
        fieldArray.push('`' + field + '` = ' + db.escape(editData[field]));
      }
      if (fieldArray.length <= 0) {
        return cb(); // nothing to do
      }
      qStr += ' SET ' + fieldArray.join(',');
      qStr += ' WHERE tp_rev_id = ' + db.escape(args.tp_rev_id);
      db.queryData(qStr, cb);
    });
  }
}

//============================================================================//
//============================================================================//
//
//  field validity testing  (and roles checks)
//

var validSiteCounts = { 1: true, 2: true, 4: true, 8: true };

function checkInt(field, value) {
  if (value === null) { return value; }
  var intVal = parseInt(value);
  if (isNaN(intVal)) {
    throw Error('invalid ' + field + ': ' + value);
  }
  return intVal;
}

function checkIntUnsigned(field, value) {
  if (value === null) { return value; }
  var uintVal = checkInt(field, value);
  if (uintVal < 0) {
    throw Error('invalid ' + field + ': ' + value);
  }
  return uintVal;
}

function checkSiteCount(field, value) {
  if (value === null) { return value; }
  var count = checkIntUnsigned(field, value);
  if (!validSiteCounts[count]) {
    throw Error('invalid ' + field + ': ' + value);
  }
  return count;
}

function checkFloat(field, value) {
  if (value === null) { return null; }
  var number = parseFloat(value);
  if (isNaN(number)) {
    throw Error('invalid numeric value: ' + value);
  }
  return number;
}

function checkTemperature(field, value) {
  if (value === null) { return null; }
  var temp = checkFloat(field, value);
  if (temp < -50) { throw Error('crazy low temperature detected'); }
  if (temp > 200) { throw Error('crazy high temperature detected'); }
  return temp;
}

function checkBytes(field, value) {
  if (value === null) { return null; }
  var bytes = checkInt(field, value);
  if (bytes <= 0) {
    throw Error('invalid ' + field + ': ' + value);
  }
  if (bytes > (32 * Math.pow(2, 30))) { // 32GiB maximum
    throw Error('crazy number of bytes: ' + bytes);
  }
  return bytes;
}

function checkPercent(field, value) {
  if (value === null) { return null; }
  var percent = checkFloat(field, value);
  if (isNaN(percent))  { throw Error('invalid ' + field + ': ' + value); }
  if (percent <   0.0) { throw Error('invalid negative percentage');     }
  if (percent > 100.0) { throw Error('invalid percentage above 100%');   }
  return percent;
}

function checkText(field, value) {
  if (value === null) { return null; }
  if (typeof(value) !== 'string') {
    throw Error('invalid text type');
  }
  return value;
}

function checkTextMaxLength(field, value, maxLen) {
  if (value === null) { return null; }
  checkText(field, value);
  if (value.length > maxLen) {
    throw Error('string is too long: ' + value.length + ' vs. ' + maxLen);
  }
  return value;
}

function checkText255(field, value) {
  return checkTextMaxLength(field,value, 255);
}

//============================================================================//

var fieldChecks = {

  site_count:             { func: checkSiteCount,    role: 'TE', draft:  true },
  vector_size:            { func: checkBytes,        role: 'TE', draft:  true },
  disk_space:             { func: checkBytes,        role: 'TE', draft:  true },
  ate_os_version_id:      { func: checkIntUnsigned,  role: 'TE', draft:  true },
  ate_sw_version_id:      { func: checkIntUnsigned,  role: 'TE', draft:  true },
  reason:                 { func: checkText,         role: 'TE', draft:  true },
  comments:               { func: checkText,         role: 'TE', draft:  true },
  special_hw:             { func: checkText,         role: 'TE', draft:  true },
  special_instrs:         { func: checkText,         role: 'TE', draft:  true },
  temperature:            { func: checkTemperature,  role: 'TE', draft:  true },
};

//============================================================================//

function checkFields(peodb, args, cb) {
  var editData = args.editData;

  var reqRoles = {};

  var draftOnly = false;

  for (var field in editData) {
    var check = fieldChecks[field];
    if (!check) {
      return cb(Error('unknown tp_rev field: ' + field));
    }
    var checkFunc = check.func;

    var value = editData[field];

    draftOnly = draftOnly || check.draft;

    // convert empty strings to `null`s
    if ((typeof(value) === 'string') && (value.length <= 0)) {
      editData[field] = null;
      value = null;
    }

    var value
    try {
      checkFunc(field, value);
    } catch (err) {
      return cb(Error(err));
    }

    reqRoles[check.role] = field; // collect the roles
  }

  // check the required roles
  var rolesArray = [];
  for (var role in reqRoles) {
    rolesArray.push(role);
  }
  async.forEachSeries(rolesArray,
    function(role, cb) {
      peodb.checkTPrevRole(args, role, function(err) {
        return cb(err);
      });
    },
    function(err) {
      return cb(err, draftOnly);
    }
  );
}

//============================================================================//
