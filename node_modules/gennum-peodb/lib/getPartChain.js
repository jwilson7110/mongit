//============================================================================//
//
//  FIXME - this should be good enough to handle simple cases, including
//          simple "retest" loopbacks. it falls apart when parts have multiple
//          sources (and it should really return in a different format).
//          FIXME - getPartChain() needs more work
//
//  FIXME - this should all be done using one transaction
//
//============================================================================//

var print = console.log;

var async = require('async');

//============================================================================//

module.exports = function(PEODB) {

  var requiredArgs = [
    'part_id',
  //'needTPs',  -- optional argument, set to `true` to have the `tp_sets`,
  //               `tps`, and `tp_revs` parameters added to the parts
  ];

  //==========================================================================//

  PEODB.prototype.getPartChain = function(args, cb) {
    var peodb = this;

    if (!(args instanceof Object)) {
      args = { part_id: args };
    }

    var needTPs = !!args.needTPs;

    var missingArg = peodb.checkArgs(requiredArgs, args);
    if (missingArg) {
      return cb(Error('missing required argument: ' + missingArg));
    }

    var db = peodb.sharedDB;

    // make sure that part_id is an integer, we use exact tests during
    // the partflow traversal, and that only works if it is an integer
    var part_id = parseInt(args.part_id);

    findPartflowIDs(db, part_id, function(err, partflow_ids) {
      if (err) {
        return cb(err);
      }
      if (partflow_ids.length === 0) {
        return noFlowResult(peodb, part_id, cb);
      }

      var flowInfos = {};
      async.forEachSeries(partflow_ids,
        function(partflow_id, cb) {
          peodb.getPartflowInfo(partflow_id, function(err, flowInfo) {
            flowInfos[partflow_id] = flowInfo;
            cb(err);
          });
        },
        function(err) {
          if (err) {
            return cb(err);
          }
          buildChain(db, part_id, flowInfos, needTPs, function(err, chainInfo) {
            return cb(err, chainInfo);
          });
        }
      );
    });
  }

  //==========================================================================//

  function findPartflowIDs(db, part_id, cb) {
    var qStr =
      'SELECT distinct partflow_id FROM partflow_parts'
      + ' WHERE part_id = ' + db.escape(part_id);
    db.queryData(qStr, function(err, data) {
      if (err) {
        return cb(err);
      }
      return cb(null, data.toArray());
    });
  }

  //==========================================================================//

  function noFlowResult(peodb, part_id, cb) {
    peodb.getPartInfo(part_id, function(err, partInfo) {
      if (err) {
        return cb(err);
      }
      var result = { parts: [], steps: [] };
      result.parts.push({
        part_id:        partInfo.part_id,
        part_number:    partInfo.part_number,
        part_type_id:   partInfo.part_type_id,
        part_type_abbr: partInfo.part_type_abbr,
      });
      return cb(null, result);
    });
  }

  //==========================================================================//

  var mergeFields = {
    parts:        true,
    steps:        true,
    part_outputs: true,
    step_outputs: true,
  };

  function mergeFlowInfos(flowInfos) {
    var merged = {};
    for (var pfid in flowInfos) {
      var info = flowInfos[pfid];
      for (var field in info) {
        if (mergeFields[field]) {
          var elems = info[field];
          merged[field] = merged[field] || {};
          for (var e in elems) {
            merged[field][e] = elems[e];
          }
        }
      }
    }
    return merged;
  }

  //==========================================================================//

  function tracebackPart(part_id, flowInfo, collected) {
    if (!collected.parts[part_id]) {
      collected.parts[part_id] = true;
      collected.partsArray.push(flowInfo.parts[part_id]);
      for (var k in flowInfo.step_outputs) {
        var output = flowInfo.step_outputs[k];
        if (output.part_id === part_id) {
          tracebackStep(output.step_id, flowInfo, collected);
        }
      }
    }
  }

  function tracebackStep(step_id, flowInfo, collected) {
    if (!collected.steps[step_id]) {
      collected.steps[step_id] = true;
      collected.stepsArray.push(flowInfo.steps[step_id]);
      for (var k in flowInfo.part_outputs) {
        var input = flowInfo.part_outputs[k];
        if (input.step_id === step_id) {
          tracebackPart(input.part_id, flowInfo, collected);
        }
      }
    }
  }

  //==========================================================================//

  function buildChain(db, last_part_id, flowInfos, needTPs, cb) {

    var flowInfo = mergeFlowInfos(flowInfos);

    var collected = {
      parts: {}, partsArray: [],
      steps: {}, stepsArray: [],
    };

    tracebackPart(last_part_id, flowInfo, collected);

    collected.parts = collected.partsArray; delete collected.partsArray;
    collected.steps = collected.stepsArray; delete collected.stepsArray;

    collected.parts.reverse();
    collected.steps.reverse();

    if (needTPs) {
      return addTestPrograms(db, collected.parts, flowInfo, function(err) {
        if (err) {
          return cb(err);
        }
        return cb(null, { parts: collected.parts });
      });
    }

    //return cb(null, collected); // FIXME - getPartChain() removing the steps until they are better defined
    return cb(null, { parts: collected.parts });
  }

  //==========================================================================//
  //
  //  Add the `tp_sets`, `tps`, and `tp_revs` fields to the output parts.
  //

  function addTestPrograms(db, parts, flowInfo, cb) {
    var steps    = flowInfo.steps;
    var stepouts = flowInfo.step_outputs;
    for (var p = 0; p < parts.length; p++) {
      var part = parts[p];
      var part_id = part.part_id;
      part.tp_sets = [];
      part.tps     = [];
      part.tp_revs = [];
      for (var out_id in stepouts) {
        var stepout = stepouts[out_id];
        if (stepout.part_id === part_id) {
          var step = steps[stepout.step_id];
          if (step.tp_set_id) {
            part.tp_sets.push({
              tp_set_id:   step.tp_set_id,
              tp_set_name: step.tp_set_name,
            });
          }
          if (step.tp_rev_id) { // tp_revs with hardbins associated to the parts
            part.tp_revs.push({
              tp_rev_id:   step.tp_rev_id,
              tp_rev_name: step.tp_rev_name,
            });
          }
          // NOTE:  the `tps` array is not filled in here
        }
      }
    }
    return addTPs(db, parts, cb);
  }

  //
  //  Add TPs to the parts based on their tp_set linkage
  //
  function addTPs(db, parts, cb) {
    var all_tp_set_ids = [];
    for (var p = 0; p < parts.length; p++) {
      var tp_sets = parts[p].tp_sets;
      for (var i = 0; i < tp_sets.length; i++) {
        all_tp_set_ids.push(tp_sets[i].tp_set_id);
      }
    }
    if (all_tp_set_ids.length <= 0) {
      return cb(); // leave the part.tps fields as empty arrays
    }

    // get the tp_set_id -> [ tp_id, ... ]  map
    var qStr =
      'SELECT'
    + '    ts.tp_set_id'
    + '  , tp.tp_id, tp.name'
    + '  FROM tp_sets ts'
    + '  JOIN tps     tp ON (tp.tp_set_id = ts.tp_set_id)'
    + '  WHERE ts.tp_set_id IN (' + all_tp_set_ids.join(',') + ')'
    ;
    db.queryData(qStr, function(err, data) {
      if (err) {
        return cb(err);
      }
      var setMap = {};
      for (var r = 0; r < data.rows.length; r++) {
        var row = data.rows[r];
        var array = setMap[row.tp_set_id] || [];
        setMap[row.tp_set_id] = array;
        array.push(row);
      }
      for (var p = 0; p < parts.length; p++) {
        var part = parts[p];
        var tp_sets = part.tp_sets;
        var tp_ids = {};
        for (var r = 0; r < tp_sets.length; r++) {
          var tp_set = tp_sets[r];
          var array = setMap[tp_set.tp_set_id];
          if (array) {
            for (var i = 0; i < array.length; i++) {
              tp_ids[array[i].tp_id] = array[i];
            }
          }
        }
        for (var tp_id in tp_ids) {
          var row = tp_ids[tp_id];
          part.tps.push({
            tp_id:   row.tp_id,
            tp_name: row.name
          });
        }
      }
      return cb();
    });
  }

  //==========================================================================//

}

//============================================================================//
