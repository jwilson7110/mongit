//============================================================================//
//
//  Find the potential input and outputs for a Test Program Revision
//  based on the connections to its associated Test Program Set. For
//  Wafer Test programs, we have to scan through the output chains
//  until we find a die part (WB, WG, WR, WQ, etc.. need not apply).
//
//  NOTE: For FT programs, we just use getStepParts()
//
//============================================================================//

var print = console.log;

var async = require('async');

//============================================================================//

module.exports = function(PEODB) {

  var requiredArgs = [ // either
    'tp_set_step_id',
    'tp_stage_type',
  ];

  PEODB.prototype.getTPsetOutputs = function(args, cb) {
    var peodb = this;

    if (!(args instanceof Object)) {
      args = { step_id: args };
    }

    var missingArg = peodb.checkArgs(requiredArgs, args);
    if (missingArg) {
      return cb(Error('missing required argument: ' + missingArg));
    }

    var step_id = args.tp_set_step_id;
    var stepArgs = { step_id: step_id };

    if (args.tp_stage_type !== 'W') {
      return peodb.getStepOutputs(stepArgs, cb);
    }

    var db = peodb.sharedDB;

    getStepPartflow(db, step_id, function(err, partflow_id) {
      if (err) {
        return cb(err);
      }

      getPartflow(db, partflow_id, function(err, partflow) {
        if (err) {
          return cb(err);
        }

        var dieParts = findDies(step_id, partflow);
        return getPartInfo(db, dieParts, cb);
      });
    });
  }
}

//============================================================================//

function getStepPartflow(db, step_id, cb) {
  var qStr =
    'SELECT partflow_id'
  + ' FROM partflow_steps'
  + ' WHERE step_id = ' + db.escape(step_id)
  ;
  return db.query1Value(qStr, cb);
}

//============================================================================//

var stepsBasis = 'SELECT step_id FROM partflow_steps WHERE partflow_id = ';

var partsBasis =
  'SELECT p.part_id, pt.abbr'
+ ' FROM  partflow_parts pfp'
+ ' JOIN  parts          p   ON (p.part_id = pfp.part_id)'
+ ' JOIN  part_types     pt  ON (pt.part_type_id = p.part_type_id)'
+ ' WHERE partflow_id = '
;

var inputsBasis =
  'SELECT po.part_id, po.step_id'
+ ' FROM  part_outputs   po'
+ ' JOIN  partflow_steps ps ON (ps.step_id = po.step_id)'
+ ' WHERE partflow_id = '
;

var outputsBasis =
  'SELECT so.part_id, so.step_id'
+ ' FROM  step_outputs   so'
+ ' JOIN  partflow_steps ps ON (ps.step_id = so.step_id)'
+ ' WHERE partflow_id = '
;

function getPartflow(db, partflow_id, cb) {
  var target = db.escape(partflow_id);
  async.parallel({
    parts:   function(cb) { db.queryData(partsBasis   + target, cb); },
    inputs:  function(cb) { db.queryData(inputsBasis  + target, cb); },
    outputs: function(cb) { db.queryData(outputsBasis + target, cb); },
  },
  cb);
}

//============================================================================//

var partInfoBasis = // matches the getStepParts() query
  'SELECT'
+ '     p.part_id         AS part_id'
+ '   , p.part_number     AS part_number'
+ '   , p.description     AS description'
+ '   , p.state           AS state'
+ '   , pt.part_type_id   AS part_type_id'
+ '   , pt.name           AS part_type_name'
+ '   , pt.abbr           AS part_type_abbr'
+ '   , pt.primary_type   AS part_type_primary'
+ ' FROM parts      p'
+ ' JOIN part_types pt  ON (pt.part_type_id = p.part_type_id)'

function getPartInfo(db, part_ids, cb) {
  var qStr = partInfoBasis;
  if (part_ids.length > 0) {
    qStr += ' WHERE part_id IN (' + part_ids.join(',') + ')';
  } else {
    qStr += ' WHERE 1 = 0'; // return an empty table for the fields info
  }
  db.queryData(qStr, cb);
}

//============================================================================//
//============================================================================//

function findDies(step_id, partflow, cb) {
  mapParts(partflow); // { part_id: abbr }
  partflow.inputs  = arrayToMap(partflow.inputs,  'part_id', 'step_id');
  partflow.outputs = arrayToMap(partflow.outputs, 'step_id', 'part_id');

  var collected = { dies: {}, parts: {}, steps: {} };
  traceStep(step_id, partflow, collected);

  var dies = [];
  for (var key in collected.dies) {
    dies.push(key);
  }
  return dies;
}

//============================================================================//

function traceStep(step_id, partflow, collected) {
  if (collected.steps[step_id]) {
    return;
  }
  collected.steps[step_id] = true;

  var outParts = partflow.outputs[step_id];
  for (var part_id in outParts) {
    tracePart(part_id, partflow, collected);
  }
}

function tracePart(part_id, partflow, collected) {
  if (collected.parts[part_id]) {
    return;
  }
  collected.parts[part_id] = true;

  if (partflow.parts[part_id] === 'WT') { // found one, store and leave
    collected.dies[part_id] = true;
    return;
  }

  var outSteps = partflow.inputs[part_id];
  for (var step_id in outSteps) {
    traceStep(step_id, partflow, collected);
  }
}

//============================================================================//

function mapParts(partflow) {
  var parts = {};
  var rows = partflow.parts.rows;
  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    parts[row.part_id] = row.abbr;
  }
  partflow.parts = parts;
}

function arrayToMap(t, keyName, valName) {
  var m = {};
  var rows = t.rows;
  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    var key = row[keyName];
    var val = row[valName];
    var a = m[key] || {};
    m[key] = a;
    a[val] = true;
  }
  return m;
}

//============================================================================//
//============================================================================//
